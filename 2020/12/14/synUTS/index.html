<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>Unix迷失的唤醒</title>
  
  <link rel="canonical" href="https://yanmulin.me/2020/12/14/synUTS/">
  
  <meta name="description" content="这篇论文介绍了Unix内核如何为多核处理器设计的设计基于事件的sleep lock，并利用自旋锁解决唤醒时的竞争问题。这篇论文分析了内核中许多潜在竞争问题，结合Model Checking和Spin，十分值得琢磨且有趣。 Sleep Lock 与唤醒竞争锁的获取与释放在Unix内核中被当作事件处理：">
  
  
  <meta name="author" content="yanmulin">
  <meta property="og:site_name" content="颜木林的流水账" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Unix迷失的唤醒" />
  
  <meta property="og:description" content="这篇论文介绍了Unix内核如何为多核处理器设计的设计基于事件的sleep lock，并利用自旋锁解决唤醒时的竞争问题。这篇论文分析了内核中许多潜在竞争问题，结合Model Checking和Spin，十分值得琢磨且有趣。 Sleep Lock 与唤醒竞争锁的获取与释放在Unix内核中被当作事件处理：">
  
  <meta property="og:url" content="https://yanmulin.me/2020/12/14/synUTS/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="../fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="../fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  .category-link {]
    text-decoration-color: transparent;
    border-color: #0FA0CE;
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .post-body h3::before {
    color: #0FA0CE;
  } 
  .post-body h4::before {
    color: #0FA0CE;
  } 
  .post-body h5::before {
    color: #0FA0CE;
  } 
  .post-body h6::before {
    color: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

<meta name="generator" content="Hexo 5.2.0"></head>

<body class="darkmode">
  <div class="container">
    <div class="row">
      <div>
        <div class="row">
  

  <div class="twelve columns">
    <div class="row" style="margin-bottom: 2.6rem">
        
          
            
              <a href="/archives" class="mr u-pull-right">Notes</a>
            
          
            
              <a href="/About" class="mr u-pull-right">About</a>
            
          
          <a href="/" class="u-pull-right mr">Home</a>
        
      </div>
  </div>

  
    <h2>Unix迷失的唤醒</h2>
    <p class="post-info">Dec 14, 2020 <a class="category-link" href="/categories/unclassified/">unclassified</a></p>
  
</div>

        <div class="trans">
          <div class="post-body">
  
  <p><a target="_blank" rel="noopener" href="https://www.usenix.org/legacy/publications/compsystems/1990/sum_ruane.pdf">这篇论文</a>介绍了Unix内核如何为多核处理器设计的设计基于事件的sleep lock，并利用自旋锁解决唤醒时的竞争问题。这篇论文分析了内核中许多潜在竞争问题，结合Model Checking和Spin，十分值得琢磨且有趣。</p>
<h3 id="Sleep-Lock-与唤醒竞争"><a href="#Sleep-Lock-与唤醒竞争" class="headerlink" title="Sleep Lock 与唤醒竞争"></a>Sleep Lock 与唤醒竞争</h3><p>锁的获取与释放在Unix内核中被当作事件处理：获取锁时，进程检查资源占用情况，如果已被占用，则把进程放入等待队列，接着睡眠等待；释放锁时，把所有等待队列中的进程唤醒，令他们争夺资源，只有一个进程可以争夺到资源，于是其他进程继续睡眠等待。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process A</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-></span>lock<span class="token punctuation">)</span>
  <span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process B</span>
r<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">wakeup</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>这里存在一个竞争问题。假设初始由进程B占用<code>r-&gt;lock</code>，当进程A运行到第2-3行间，定时器中断来临，切换到进程B运行。接着进程B释放锁<code>r-&gt;lock = 0</code>，执行唤醒<code>wakeup</code>，但这时进程A还没有睡眠。等轮到进程A运行并陷入睡眠时，进程A已经没有机会再被唤醒了。这里产生的唤醒竞争，是本文要解决的核心问题。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>由于竞争产生的根源是中断导致的上下文切换，禁用中断至少可以为单核处理器解决问题。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process A</span>
<span class="token function">interruption_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-></span>lock<span class="token punctuation">)</span>
  <span class="token function">sleep</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">interruption_endable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process B</span>
<span class="token function">interruption_disable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">wakeup</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">interruption_endable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>尽管禁用了中断，并发在多核处理器仍然存在。这里引入自旋锁解决问题。自旋锁可以提供处理器级别的同步，用于短期的互斥访问。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process A</span>
<span class="token function">spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-></span>lock<span class="token punctuation">)</span>
  <span class="token function">sleepl</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
r<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">freelock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process B</span>
r<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">waitlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wakeup</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里<code>waitlock</code>只等待自旋锁被释放，而不获取锁。使用<code>waitlock</code>而非<code>spinlock</code>可以减少争夺锁带来的性能下降。进程B在释放<code>r-&gt;lock</code>后等待自旋锁的释放，确保进程A要么陷入睡眠状态，要么跳过<code>while</code>循环。睡眠状态的进程不能持有自旋锁，所以自旋锁被传入<code>sleepl</code>，陷入睡眠前释放，被唤醒后重新获取。</p>
<h3 id="引入want减少唤醒次数"><a href="#引入want减少唤醒次数" class="headerlink" title="引入want减少唤醒次数"></a>引入want减少唤醒次数</h3><p><code>wakeup</code>实际上将所有等待队列中的进程唤醒，带来很大的上下文切换开销，引入一个<code>want</code>变量避免不必要的唤醒。但是也引入了新的竞争问题。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process A</span>
<span class="token function">spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>r<span class="token operator">-></span>lock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  r<span class="token operator">-></span>want <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token function">sleepl</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
r<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">freelock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process B</span>
r<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">waitlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token operator">-></span>want<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  r<span class="token operator">-></span>want <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">waitlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">wakeup</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一定需要两个<code>waitlock</code>，第一个用于保护<code>want</code>必须在测试前被置一，第二个确保不存在唤醒竞争。一个有点难的问题：如果不存在第二个<code>waitlock</code>，竞争如何触发？假设进程A刚刚被唤醒，而进程B正在释放资源。由于进程A还没尝试获得自旋锁，进程B在第一个<code>waitlock</code>没有遇到障碍并通过了<code>r-&gt;want</code>的测试（其他进程设置了<code>r-&gt;want</code>）。接着进程A从<code>sleepl</code>返回，测试<code>r-&gt;lock</code>，可资源已经被其他进程抢走，于是进程A重新进入睡眠。在这个情况下，如果没有第二个<code>waitlock</code>，唤醒竞争仍然存在。</p>
<h3 id="条件获取Sleep-Lock"><a href="#条件获取Sleep-Lock" class="headerlink" title="条件获取Sleep Lock"></a>条件获取Sleep Lock</h3><p>Unix内核中有这样的情况：尽管进程抢到了锁，它也不一定获取这个锁。比如文件系统的空闲块，以链表的形式存储在内存中。进程只在链表满的时候才真正获取保护链表的锁。这个例子中，自旋锁还保护链表的操作。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fp<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>fp<span class="token operator">-></span>lock<span class="token punctuation">)</span>
  <span class="token function">sleepl</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fp<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isfull</span><span class="token punctuation">(</span>fp<span class="token operator">-></span>free<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  fp<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token function">freelock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fp<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  write fp<span class="token operator">-></span>free into disk
  set fp<span class="token operator">-></span>free to empty
  <span class="token function">spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fp<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  fp<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token function">wakeup</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
append block being freed to fp<span class="token operator">-></span>free
<span class="token function">freelock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fp<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以考虑下面的唤醒实现为什么不可行。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">fp<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>fp<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wakeup</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>利用Spin可以验证，这个唤醒实现的问题在于可能导致链表溢出。比如进程在释放<code>fp-&gt;lock</code>后被打断，链表被填满，然后进程恢复并继续运行到13行，导致链表溢出。</p>
<p>这里同样可以引入<code>want</code>变量减少唤醒次数。</p>
<h3 id="跨进程消息队列的Sleep-Lock"><a href="#跨进程消息队列的Sleep-Lock" class="headerlink" title="跨进程消息队列的Sleep Lock"></a>跨进程消息队列的Sleep Lock</h3><p>消息队列有三个锁：队列锁，消息锁和自旋锁。队列锁用于操作队列，消息锁用于消费者等待空队列，自旋锁用于保障处理器级别的同步。其中自旋锁是IPC全局共享的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Sender</span>
<span class="token function">spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>qp<span class="token operator">-></span>lock<span class="token punctuation">)</span>
  <span class="token function">sleepl</span><span class="token punctuation">(</span>qp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
qp<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">freelock</span><span class="token punctuation">(</span>qp<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Enqueue a message */</span>
<span class="token function">wakeup</span><span class="token punctuation">(</span>qp<span class="token operator">-></span>qnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
qp<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">waitlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wakeup</span><span class="token punctuation">(</span>qp<span class="token operator">-></span>qnum<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Receiver</span>
loop<span class="token operator">:</span>
<span class="token function">spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>qp<span class="token operator">-></span>lock<span class="token punctuation">)</span>
  <span class="token function">sleepl</span><span class="token punctuation">(</span>qp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
qp<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">freelock</span><span class="token punctuation">(</span>qp<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* if no message to read */</span>
<span class="token function">spinlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
qp<span class="token operator">-></span>lock <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">wakeup</span><span class="token punctuation">(</span>qp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sleepl</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>qp<span class="token operator">-></span>qnum<span class="token punctuation">,</span> <span class="token operator">&amp;</span>msg_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">freelock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>msg_lk<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">goto</span> loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先，Receiver要确保在释放<code>qp-&gt;lock</code>前获取自旋锁，否则<code>sleepl(&amp;qp-&gt;qnum, &amp;msg_lk)</code>对应的唤醒可能丢失。其次，<code>wakeup(qp-&gt;qnum)</code>前面不需要等待自旋锁，因为此时Sender已经拥有<code>qp-&gt;lock</code>，Receiver要么正在等待<code>qp-&gt;qnum</code>，要么正在等待<code>qp-&gt;lock</code>，不可能产生唤醒竞争。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>通过几个唤醒竞争的例子，可以一窥并发编程与竞争分析的难点。正如信息安全学，原语并不能保证系统的安全性。程序的线程安全隐患，往往在于非常隐蔽且微妙的地方。</p>

  
  

</div>

          
<footer>
  <span className='cc-licence'>CC BY-NC-SA 4.0</span> © 2020 🐣
</footer>


        </div>
      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>
  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>
