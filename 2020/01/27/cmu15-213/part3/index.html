<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>CMU 15-213 Part4 Machine Programming I</title>
  
  <link rel="canonical" href="https://yanmulin.me/2020/01/27/cmu15-213/part3/">
  
  <meta name="description" content="汇编基础x86-64架构计算机系统架构(Architecture)，指的是计算机的硬件系统对软件层（汇编语言开发者）的抽象，包括了处理器的寄存器设计和指令集。x86架构可以追溯到上世纪80年代Intel公司开发的80x86系列处理器，采用的是复杂指令集(CISC，相对于ARM芯片采用的精简指令集，R">
  
  
  <meta name="author" content="yanmulin">
  <meta property="og:site_name" content="颜木林的流水账" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="CMU 15-213 Part4 Machine Programming I" />
  
  <meta property="og:description" content="汇编基础x86-64架构计算机系统架构(Architecture)，指的是计算机的硬件系统对软件层（汇编语言开发者）的抽象，包括了处理器的寄存器设计和指令集。x86架构可以追溯到上世纪80年代Intel公司开发的80x86系列处理器，采用的是复杂指令集(CISC，相对于ARM芯片采用的精简指令集，R">
  
  <meta property="og:url" content="https://yanmulin.me/2020/01/27/cmu15-213/part3/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="../fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="../fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  .category-link {]
    text-decoration-color: transparent;
    border-color: #0FA0CE;
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .post-body h3::before {
    color: #0FA0CE;
  } 
  .post-body h4::before {
    color: #0FA0CE;
  } 
  .post-body h5::before {
    color: #0FA0CE;
  } 
  .post-body h6::before {
    color: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

<meta name="generator" content="Hexo 5.2.0"></head>

<body class="darkmode">
  <div class="container">
    <div class="row">
      <div>
        <div class="row">
  

  <div class="twelve columns">
    <div class="row" style="margin-bottom: 2.6rem">
        
          
            
              <a href="/archives" class="mr u-pull-right">Notes</a>
            
          
            
              <a href="/About" class="mr u-pull-right">About</a>
            
          
          <a href="/" class="u-pull-right mr">Home</a>
        
      </div>
  </div>

  
    <h2>CMU 15-213 Part4 Machine Programming I</h2>
    <p class="post-info">Jan 27, 2020 <a class="category-link" href="/categories/CMU-15-213/">CMU 15-213</a></p>
  
</div>

        <div class="trans">
          <div class="post-body">
  
  <h3 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h3><h4 id="x86-64架构"><a href="#x86-64架构" class="headerlink" title="x86-64架构"></a>x86-64架构</h4><p>计算机系统架构(Architecture)，指的是计算机的硬件系统对软件层（汇编语言开发者）的抽象，包括了处理器的寄存器设计和指令集。x86架构可以追溯到上世纪80年代Intel公司开发的80x86系列处理器，采用的是复杂指令集(CISC，相对于ARM芯片采用的精简指令集，RISC)。而x86-64架构是x86架构的64位版本，目前已经完全取代了32位的机器。从硬件角度来看，64位字长指的是CPU在一个时钟周期可以处理长度为64位的数据。x86-64架构提供了16个数据寄存器，除了个别有特殊用途（比如%rsp，用作栈顶指针），其余都可用来存放临时数据。除了数据寄存器，还有IP寄存器，指向下条指令的地址；以及状态码（Status Code)，有SF(Sign Flag)，ZF(Zero Flag)，CF(Carry Flag)等等，在代数计算指令执行完成后被自动设置表示结果的状态。</p>
<p><img src="https://i.loli.net/2020/02/02/bc4fgr6WeEOPw5i.png" alt="x86-64架构寄存器一览"></p>
<h4 id="汇编的数据类型和取值方式"><a href="#汇编的数据类型和取值方式" class="headerlink" title="汇编的数据类型和取值方式"></a>汇编的数据类型和取值方式</h4><p>汇编语言中只用整型和浮点两种数据类型，整型分为1,2,4,8等四种字节长度，浮点分为单精度(float)和双精度(double)两种类型。x86-64架构下，汇编语言可以通过3种方式来读写数据：字面量，寄存器和内存。</p>
<ul>
<li><p>字面量：相当于硬编码在程序中，如$1等</p>
</li>
<li><p>寄存器：可以通过寄存器的名字来访问，如%rax, %r12等</p>
</li>
<li><p>内存：格式为D(Rb, Ri, S)，D，Rb，Ri，S分别表示偏移(Displacement)，基址(Base)，下标(Index)，长度(Scale)，前三者可以取值为寄存器或字面量，而长度只可以取值字面量1,2,4,8。地址的计算公式为D+Rb+Ri*Scale。用法如4(%rbx, %rdi, 4), (%rbx), (,%rax,2)</p>
</li>
</ul>
<h4 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h4><p>下图列出了x86-64中常用指令。</p>
<p><img src="https://i.loli.net/2020/02/02/vr5RFedwBnDcaNU.png" alt="x86-64常用指令"></p>
<p><img src="https://i.loli.net/2020/02/02/yYoQSqbAGMPIC4N.png" alt="x86-64常用指令"></p>
<ul>
<li><p>计算数前者是源，后者是目标</p>
</li>
<li><p><code>movq src, dst</code>: 移动数据，注意不允许将字面量作为dst，或者src和dst都是内存取值。</p>
</li>
<li><p><code>leaq src, dst</code>: 本作为地址计算，但gcc常常用来优化代数计算，如<code>leaq (%rdi,%rdi,2), %rax</code>用来计算<code>t = x+2*x</code></p>
</li>
<li><p><code>sarq</code>是算术右移(Arithmetic Shift)，<code>shrq</code>是逻辑右移(Logical Shift)</p>
</li>
</ul>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>x86-64处理浮点数使用一套与整数不同的硬件和指令。</p>
<p><img src="https://i.loli.net/2020/02/02/AUQnXkHuy9zh2rd.png" alt="浮点数专用寄存器"></p>
<p><img src="https://i.loli.net/2020/02/02/bU6mWDzEVqlZ2ro.png" alt="浮点数运算指令"></p>
<p>其中，为了加速音视频等运算，浮点数的<code>addps</code>指令允许多个浮点数并行运算。</p>
<h3 id="C语句对应的汇编代码"><a href="#C语句对应的汇编代码" class="headerlink" title="C语句对应的汇编代码"></a>C语句对应的汇编代码</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>根据机器系统和编译选项设置的差异，编译器会对C语言源代码进行不同程度的优化，所以在每台机器编译得到的汇编代码都会有所不同。利用gcc，我们通过下面的命令来生成<strong>未优化</strong>的汇编代码：</p>
<pre class="line-numbers language-none"><code class="language-none">gcc -Og xxx.c -S xxx.a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>由于汇编代码和机器码是一一对应的关系。我们可以通过下面的命令将目标文件或可执行文件(.o/.out)的机器码反汇编(Disassemble)为汇编代码：</p>
<pre class="line-numbers language-none"><code class="language-none">objdump -d xxx.o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>第三种读汇编代码的方式是通过调试器gdb，调试文件需要在编译时需要设置调试选项：</p>
<pre class="line-numbers language-none"><code class="language-none">gdb xxx.out
disassemble &lt;function_name&gt;&#x2F;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>更多的gdb教程可以参考<a target="_blank" rel="noopener" href="http://beej.us/guide/bggdb/">Quick Guide to GDB</a>，以及<a target="_blank" rel="noopener" href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">Cheat Sheet</a></p>
<h4 id="条件控制-Conditional-Jumping"><a href="#条件控制-Conditional-Jumping" class="headerlink" title="条件控制(Conditional Jumping)"></a>条件控制(Conditional Jumping)</h4><p>条件控制利用测试语句和跳转语句(Jumping)实现。测试语句不保存计算结果，只影响状态位。测试语句有：</p>
<ul>
<li><p><code>cmpq src2, src1</code>：计算src1-src2</p>
</li>
<li><p><code>testq src2, src1</code>：计算src1&amp;src2</p>
</li>
</ul>
<p>跳转语句根据使用的状态码分为不同的版本：</p>
<p><img src="https://i.loli.net/2020/02/02/qYU5F7H8Zwyb6GV.png" alt="x86-64跳转语句"></p>
<p>可以使用goto语句来表示跳转的逻辑：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x3D;ntest &#x3D; !Test;
&#x3D;if (ntest) goto Else;
&#x3D;&#x2F;&#x2F; then ...
&#x3D;goto Done;
Else:
&#x2F;&#x2F; else ...
Done:
&#x2F;&#x2F; ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="条件转移-Conditional-Move"><a href="#条件转移-Conditional-Move" class="headerlink" title="条件转移(Conditional Move)"></a>条件转移(Conditional Move)</h4><p>C语言中if-else语句和?:表达式还可以对应一种叫作<strong>条件转移</strong>的汇编实现。</p>
<p>这种实现提前计算好每个分支的值，然后根据测试值才决定采用哪一个值。</p>
<pre class="line-numbers language-none"><code class="language-none">result &#x3D; Then_Expr;
eval &#x3D; Else_Expr;
nt &#x3D; !Test;
if (nt) result &#x3D; eval;
return result;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>gcc在遇到if-else语句时会在<strong>条件控制</strong>和<strong>条件转移</strong>中二选一。由于现代处理器的流水线设计，条件控制结构的效率更高。</p>
<p>但是下面的代码会造成问题：</p>
<ul>
<li><p><code>val = Test(x) ? Hard1(x) : Hard2(x)</code>: 在分支选择前会运行Hard1(x)和Hard2(x)，可能消耗大量性能；</p>
</li>
<li><p><code>val = p ? *p : 0</code>: 尽管p为空指针，也会计算<code>*p</code>的值，导致段错误(Segmentation Fault)；</p>
</li>
<li><p><code>val = x &gt; 0 ? x*=7 : x+=3</code>: 两个有副作用的表达式都会执行，而且结果无法预测，因为执行顺序未知。</p>
</li>
</ul>
<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><ul>
<li><code>do...while</code>语句，这是汇编实现最简单的循环结构，只需要在循环体尾部增加测试语句：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">loop:
  &#x2F;&#x2F; ...Body
  if (Test)
    goto loop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>while</code>语句，有两种方式，一是进入循环时即跳转到尾部的测试部分，二是基于<code>do...while</code>语句实现，但在进入循环时先进行一次测试：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">  goto test;
loop:
  &#x2F;&#x2F; ...Body
test:
  if (Test) goto loop;
done:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">  if (!Test) goto done;
  do &#123;
      &#x2F;&#x2F; ... Body
  &#125; while (Test);
done:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>for</code>语句，在<code>while</code>语句的基础上，开头添加初始化(Init)的代码，循环体后添加更新(Update)代码：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; ...Init
while (Test) &#123;
    &#x2F;&#x2F; ...Body
    &#x2F;&#x2F; ...Update
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>下面代码使用了C语言switch语句multiple case labels, falling through cases和default case：</p>
<pre class="line-numbers language-none"><code class="language-none">int w &#x3D; 1;
switch(x) &#123;
    case 1:
        w &#x3D; y*z;
        break;
    case 2:
        w &#x3D; y&#x2F;z;
        &#x2F;* Fall Through *&#x2F;
    case 3:
        w +&#x3D; z;
        break;
    case 5:
    case 6:
        w -&#x3D; z;
        break;
    default:
        w &#x3D; 2;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>switch语句通过一种叫作**跳转表(Jump Table)**的数据结构来实现这多种特性。跳转表实际上是一个数组，x的取值作为下标，各个case代码的地址作为元素。可以用下面的语句理解跳转表的跳转过程（但C语言不支持这样的语句）：</p>
<pre class="line-numbers language-none"><code class="language-none">goto *JTab[x];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>汇编这样实现跳转过程：</p>
<pre class="line-numbers language-none"><code class="language-none">switch_eg:
    movq    %rdx, %rcx
    cmpq    $6, %rdi   # x:6
    ja      .L8
    jmp     *.L4(,%rdi,8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>%rdi存储了x的值，首先先判断x的大小，如果超过跳转表能处理的范围（小于0或大于6）则直接跳转到标签.L8，即default对应的代码处。而标签.L4处存储了跳转表，下面是跳转表的实现：</p>
<pre class="line-numbers language-none"><code class="language-none">.L4:
	.quad	.L8	# x &#x3D; 0
	.quad	.L3	# x &#x3D; 1
	.quad	.L5	# x &#x3D; 2
	.quad	.L9	# x &#x3D; 3
	.quad	.L8	# x &#x3D; 4
	.quad	.L7	# x &#x3D; 5
	.quad	.L7	# x &#x3D; 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到x=5和x=6时都跳转到标签.L7，跳转表映射到同一个值，这样就实现了multiple case labels。而falling through利用了新增的merge代码块，作为多个标签的共享代码，实现思路如下：</p>
<pre class="line-numbers language-none"><code class="language-none">case 2:
    w &#x3D; y&#x2F;z;
    goto merge;
case 3:
    w &#x3D; 1;
merge:
    w +&#x3D; z;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的汇编代码如下：</p>
<pre class="line-numbers language-none"><code class="language-none">.L5:                  # Case 2
   movq    %rsi, %rax
   cqto
   idivq   %rcx       #  y&#x2F;z
   jmp     .L6        #  goto merge
.L9:                  # Case 3
   movl    $1, %eax   #  w &#x3D; 1
.L6:                  # merge:
   addq    %rcx, %rax #  w +&#x3D; z
   ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当分支值跨度很大时，比如只有1和1000000两个分支，这时跳转表要使用1000000个条目来处理。gcc还是回到条件控制的实现方式生成汇编代码，于是无法一蹴而就地跳转到对应的分支，但可以利用类似二分查找来加速分支查找。</p>

  
  

</div>

          
<footer>
  <span className='cc-licence'>CC BY-NC-SA 4.0</span> © 2020 🐣
</footer>


        </div>
      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>
  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>
