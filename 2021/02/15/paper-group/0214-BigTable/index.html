<!DOCTYPE html>
<html lang="en">

<head>

  <!-- Minima -->
  <!-- Hexo theme created by @adisaktijrs -->

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">

  
  <title>2/14 BigTable</title>
  
  <link rel="canonical" href="https://yanmulin.me/2021/02/15/paper-group/0214-BigTable/">
  
  <meta name="description" content="BigTable 是Google早期架构的三剑客之一。相比MapReduce解决计算任务调度问题，GFS解决分布式文件系统及其容错问题，BigTable处于中间层为结构化数据存储提供了一个高效且可扩展的解决方案。 数据模型正如名字所暗示的，BigTable的抽象是数据存在一张大表中，利用Row，Co">
  
  
  <meta name="author" content="yanmulin">
  <meta property="og:site_name" content="颜木林的流水账" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="2/14 BigTable" />
  
  <meta property="og:description" content="BigTable 是Google早期架构的三剑客之一。相比MapReduce解决计算任务调度问题，GFS解决分布式文件系统及其容错问题，BigTable处于中间层为结构化数据存储提供了一个高效且可扩展的解决方案。 数据模型正如名字所暗示的，BigTable的抽象是数据存在一张大表中，利用Row，Co">
  
  <meta property="og:url" content="https://yanmulin.me/2021/02/15/paper-group/0214-BigTable/" />

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Preload fonts
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="preload" href="../fonts/dm-serif-display-v4-latin-regular.woff2" as="font" type="font/woff2" crossorigin>
  <link rel="preload" href="../fonts/inter-v2-latin-regular.woff2" as="font" type="font/woff2" crossorigin>

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  
<link rel="stylesheet" href="/css/normalize.css">

  
<link rel="stylesheet" href="/css/skeleton.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/prism-dark.css">

  
<link rel="stylesheet" href="/css/prism-line-numbers.css">

  <!-- User css -->
  

  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">

  <!-- Custom Theme Color Style
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <style>
  a:not(.icon) {
    text-decoration-color: #0FA0CE;
    background-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0) 50%,
      #0FA0CE 50%
    );
  }
  .category-link {]
    text-decoration-color: transparent;
    border-color: #0FA0CE;
  }
  blockquote {
    border-left: 8px solid #0FA0CE;
  }
  .nanobar .bar {
    background: #0FA0CE;
  }
  .post-body h3::before {
    color: #0FA0CE;
  } 
  .post-body h4::before {
    color: #0FA0CE;
  } 
  .post-body h5::before {
    color: #0FA0CE;
  } 
  .post-body h6::before {
    color: #0FA0CE;
  }
  .button.button-primary:hover,
  button.button-primary:hover,
  input[type="submit"].button-primary:hover,
  input[type="reset"].button-primary:hover,
  input[type="button"].button-primary:hover,
  .button.button-primary:focus,
  button.button-primary:focus,
  input[type="submit"].button-primary:focus,
  input[type="reset"].button-primary:focus,
  input[type="button"].button-primary:focus {
    background-color: #0FA0CE;
    border-color: #0FA0CE;
  }
  input[type="email"]:focus,
  input[type="number"]:focus,
  input[type="search"]:focus,
  input[type="text"]:focus,
  input[type="tel"]:focus,
  input[type="url"]:focus,
  input[type="password"]:focus,
  textarea:focus,
  select:focus {
    border: 1px solid #0FA0CE;
  }
</style>

  <!-- Google Analytics (With Privacy Settings On)
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  

<meta name="generator" content="Hexo 5.2.0"></head>

<body class="darkmode">
  <div class="container">
    <div class="row">
      <div>
        <div class="row">
  

  <div class="twelve columns">
    <div class="row" style="margin-bottom: 2.6rem">
        
          
            
              <a href="/archives" class="mr u-pull-right">Notes</a>
            
          
            
              <a href="/About" class="mr u-pull-right">About</a>
            
          
          <a href="/" class="u-pull-right mr">Home</a>
        
      </div>
  </div>

  
    <h2>2/14 BigTable</h2>
    <p class="post-info">Feb 15, 2021 <a class="category-link" href="/categories/Paper-Reading-Group/">Paper Reading Group</a></p>
  
</div>

        <div class="trans">
          <div class="post-body">
  
  <p>BigTable 是Google早期架构的三剑客之一。相比MapReduce解决计算任务调度问题，GFS解决分布式文件系统及其容错问题，BigTable处于中间层为结构化数据存储提供了一个高效且可扩展的解决方案。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>正如名字所暗示的，BigTable的抽象是数据存在一张大表中，利用Row，Column Family，Column和Timestamp索引数据。Row是读写的基本单位，每次对Row的读写都是原子的。表按照Row key的字典序排序，以至于相似的Row key聚集在一起（局部性，Locality），对一群相似Row key有很高的读性能。</p>
<p>Column Family是访问控制（Access Control）的基本单位，Column Family包含了一系列Column。为了便于压缩，Column Family中的Column数据类型是相同的。约定Column的key是<code>family:qualifier</code>。通常一张表包含有限的几个Column Family，但是Column Family中Column的数量是无限的，所以BigTable中都是稀疏表。</p>
<p>Timestamp与每个Cell绑定在一起。Timestamp的存在允许BigTable为每个Cell存储多个版本的数据。由于BigTable按照字典序排序，最新版本总是最先被读取到。另外，用户可以根据业务需求自定义垃圾回收策略，比如只保留最后n个版本，或者只保留一定时间内的版本。</p>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>从物理上，一个BigTable集群包含一个master，一个Chubby，一个GFS，和多个Tablet Server。从逻辑上，一个BigTable集群管理多张Table，每张Table按照排好序的Row key划分为多个Tablet，一个Tablet分为多个在GFS持久化的SSTable，一个位于GFS的commit Log，和一个当前活跃的memtable。值得注意，一张Table中Tablet之间是有序的，memtable和SSTable内部也是有序的，但是SSTable之间是无序的。</p>
<p>master有如下作用：</p>
<ol>
<li>把Tablet分配给Tablet Server</li>
<li>membership（错误检测）</li>
<li>负载均衡</li>
<li>垃圾回收</li>
</ol>
<p>Chubby是一个类似Zookeeper的高可用的锁服务。Tablet Server以在Chubby目录下创建一个文件并获取一个互斥锁的方式声明自己的存在。例外，Chubby也保存了权限与根Tablet等信息。</p>
<p>BigTable也用Tablet保存Tablet的位置信息，这种Tablet称为Metadata Tablet。类似用户Tablet，Metadata Tablet也被master指派给Tablet Server管理。BigTable采用类似B树的三层结构组织Metadata Tablet和用户Tablet，由Chubby的文件保存树根的位置。</p>
<p>每张Tablet都一个活跃的memtable位于Tablet Server的内存中，对Tablet的写操作都先写入commit log，然后写入memtable。位于内存的memtable可以很方便快速的维护row key的顺序。</p>
<p>用户把一系列相关的Column Family指定为一个Locality Group。Locality Group物理的以SSTable文件的形式持久化。文件系统把文件分成多个Block存储。SSTable把所有Block的index和row key范围存在文件末尾。从SSTable读取某个row key时，先读取末尾的indices，再利用二分查找就可以确定目标Block的index。如此只需要两次磁盘读操作就可以在SSTable中索引到一个row key。除了block indices，tablet利用bloomfilter快速判断row key是否位于该SSTable中。</p>
<h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><p>客户端一般缓存了Tablet Server的位置。当缓存失中，client递归的回到Metadata Tablet甚至更上一层最新信息。但是大多数情况，client直接与Tablet Server沟通，减轻了master的压力。</p>
<p>假设client已经得知Tablet Server的位置。如果client向Tablet Server请求读操作，Tablet Server先后通过Bloomfilter和block indices检测，目标可能位于memtable，可能位于SSTable，Tablet Server可以直接读出需要的数据。</p>
<p>如果执行一个写操作，操作先写入commit log中，然后以维持排序的方式写入memtable。当memtable超过一定大小，memtable以SSTable的形式持久化到GFS，这个过程称为minor compaction。</p>
<p>一旦持久化，SSTable中的记录是不可更改的。这一点避免了对同步机制的需要。随着系统运行，过期数据积累越来越多。所以定期需要清理过期数据，这个过程由master控制，称为major compaction。</p>
<h3 id="错误检测与恢复"><a href="#错误检测与恢复" class="headerlink" title="错误检测与恢复"></a>错误检测与恢复</h3><p>Tablet Server通过在Chubby获取互斥锁的方式声明自身的存在，终止时释放该锁。所以master也通过获取锁的情况实现错误检测。错误检测的过程如下：</p>
<ol>
<li>master周期性的询问Tablet Server锁的状态</li>
<li>如果锁丢失或连接断开，说明发生错误，可能是Tablet Server不可用，但也可能是Chubby不可用</li>
<li>master尝试向Chubby获取锁</li>
<li>如果成功获取锁，说明Tablet Server错误，则删除该锁文件，并重新分配它管理的Tablets</li>
<li>如果Chubby错误，master自杀</li>
</ol>
<p>master的恢复过程如下：</p>
<ol>
<li>在Chubby获取全局唯一的master锁，避免出现两个master</li>
<li>master扫描Chubby目录所有Tablet Server的文件</li>
<li>master向发现的Tablet Server询问它们管理的Tablets</li>
<li>master扫描Metadata Tablet发现未分配的Tablets</li>
</ol>
<p>Tablet Server在网络恢复时会尝试重新获得自己的锁，如果文件已经被删除，则自杀。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>BigTable在CAP中无法保证可用性。发生裂脑错误时只能保留与Chubby在同一分区的服务器。此外，BigTable只有行的原子操作，不支持跨行的事务操作。</p>

  
  

</div>

          
<footer>
  <span className='cc-licence'>CC BY-NC-SA 4.0</span> © 2020 🐣
</footer>


        </div>
      </div>

    </div>

  </div>
  <script src="/js/nanobar.min.js"></script>
  <script>
    var options = {
      classname: 'nanobar',
      id: 'myNanobar'
    };
    var nanobar = new Nanobar(options);
    nanobar.go(30);
    nanobar.go(76);
    nanobar.go(100);
  </script>

</body>

</html>
